<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Textbook Helper</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<script type="importmap">
		  {
			"imports": {
			  "@google/generative-ai": "https://esm.run/@google/generative-ai"
			}
		  }
		</script>	
		<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/showdown@2.0.3/dist/showdown.min.js"></script>
		<link rel="stylesheet" href="styles.css">
		<link rel="stylesheet" href="styles/default.min.css">
		<script src="highlight.min.js"></script>
		<script src="skulpt/skulpt.min.js"></script> 
		<script src="skulpt/skulpt-stdlib.js"></script> 
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
	</head>
	
	<body>
		<!-- ... Your HTML and CSS -->
		<!-- Import @google/generative-ai, as shown above. -->
		<script type="module">
			import { HarmBlockThreshold, HarmCategory, GoogleGenerativeAI } from "@google/generative-ai";
			// Default export is a4 paper, portrait, using millimeters for units
			// Fetch your API_KEY

			let api_keys = [
				"V3JpdHRlbiBieSBBdXN0aW4gUGhpbGxpcHMgQXVnLVNlcCAyMDI0",
				"AIzaSyD9xMiW0oSglYPfQh95Rn0TRHpjTZFduaE",
				"VEhJUyBXQVMgTVkgSURFQS4gRmFsbCBvZiAyMDIz",
				"QWRkaXRpb25hbCBMaWJyYXJpZXMgTGljZW5zZXMgaW5jbHVkZWQ="
			];

			const API_KEY = api_keys[1];

			// Access your API key (see "Set up your API key" above)
			const genAI = new GoogleGenerativeAI(API_KEY);
			const fileManager = new GoogleAIFileManager(API_KEY);
			console.log("HGere");
			
			const safetySettings = [
			  {
				category: HarmCategory.HARM_CATEGORY_HARASSMENT,
				threshold: HarmBlockThreshold.BLOCK_NONE,
			  },
			  {
				category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
				threshold: HarmBlockThreshold.BLOCK_NONE,
			  },
			  {
				category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
				threshold: HarmBlockThreshold.BLOCK_NONE,
			  },
			  {
				category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
				threshold: HarmBlockThreshold.BLOCK_NONE,
			  },
			];
			
			const startingPrompts = [
				"For loops in Python",
				"Introductory Algebra",
				"Basics of Cooking",
				"First steps in C++",
				"Formal writing",
				"Marine biology",
				"Advanced philosophy"
			];

			const difficultyDict = {
				"easy": "easy, beginner-friendly",
				"medium": "medium",
				"hard": "hard, complex problems, specific details of textbook",
				"impossible": "extremely hard, very complex problems and very specific questions"
			};

			const lengthDict = {
				"Short": "250",
				"Medium": "500",
				"Long": "1000",
				"Very Long": "2000"
			};
			
			var tone = "Professional, detailed, geared towards beginners";
			const modelId="gemini-1.5-flash-exp-0827";
			var tocModel = genAI.getGenerativeModel({ model: modelId, systemInstruction: `You write table of contents sections for a textbook. You are given a topic and number of pages and and include EXACTLY that many pages- no more, no less. You do not specify the number of pages or page numbers for any given section, only the order they are included.`, safetySettings});
			var model = genAI.getGenerativeModel({ model: modelId, systemInstruction: `You write textbooks and sections for textbooks and are ${tone}. Don't repeat yourself in your books.`, safetySettings});
			var chatModel = genAI.getGenerativeModel({ model: modelId, systemInstruction: `You are detailed, conversational, helpful`, safetySettings});
			var practiceModel = genAI.getGenerativeModel({ model: modelId, systemInstruction: `You write practice problems for textbooks.`, safetySettings});
			var body;
			var textbox;
			var converter = new showdown.Converter();
			var status;

			let uploadedFile = null;
			
			var bookDict = {};
			var examDict = {};
			
			let flashcards = [];
            let currentCardIndex = 0;

			function mobileAndTabletCheck() {
				let check = false;
				(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
				return check;
			};

            function displayFlashcard(index) {
                if (flashcards.length === 0) {
                    document.getElementById("flashcard-front").innerText = "No flashcards yet. Generate your book first!";
                    document.getElementById("flashcard-back").innerText = "";
                } else {
                    if (index < 0) {
                        index = flashcards.length - 1;
                    } else if (index >= flashcards.length) {
                        index = 0;
                    }

                    currentCardIndex = index;
                    document.getElementById("flashcard-front").innerHTML = converter.makeHtml(flashcards[index].front);
                    document.getElementById("flashcard-back").innerHTML = converter.makeHtml(flashcards[index].back);
                    updateCodeBlocks(); // Update code blocks on flashcard change
                }
            }

			function hasParentWithId(element, id) {
				// Start with the current element
				let currentElement = element;
				
				// Traverse up the DOM tree
				while (currentElement) {
					// Check if the current element has the specified id
					if (currentElement.id === id) {
					return true;
					}
					
					// Move to the parent node
					currentElement = currentElement.parentElement;
				}
				
				// If no parent with the specified id is found, return false
				return false;
			}


			function getAllPythonElements() {
				let allPreElements = document.querySelectorAll('pre');

				// Filter <pre> elements that have a <code> child with the class 'python' 
				// and do not have a <button> child
				let filteredPreElements = Array.from(allPreElements).filter(pre => {
					// Check if there is a <code> child with the class 'python'
					const hasPythonCode = pre.querySelector('code.python') !== null;

					// Check if there is a <button> child
					const hasButton = pre.querySelector('img') !== null;

					// Return true if there is a <code> child with the class 'python'
					// and no <button> child
					return hasPythonCode && !hasButton && !hasParentWithId("practiceTest");
				});
				
				return filteredPreElements;
			}
			
			function runPython(prog) {
				//alert(prog);
				document.getElementById('output').textContent = "";
				Sk.configure({
					output: function(text) { document.getElementById('output').textContent += text; },
					read: function(x) {
						if (Sk.builtinFiles === undefined || Sk.builtinFiles["files"][x] === undefined)
							throw "File not found: '" + x + "'";
						return Sk.builtinFiles["files"][x];
					}
				});
				(Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = 'mycanvas';
	 
				//var prog = document.getElementById('pythonCode').value;
				Sk.misceval.asyncToPromise(function() {
					return Sk.importMainWithBody("<stdin>", false, prog, true);
				}).then(function(mod) {
					console.log('Program execution completed successfully');
				}).catch(function(err) {
					document.getElementById('output').textContent = err.toString();
				});
			}
			
			function addRunPythonButtonsToFilteredPreElements() {
				let fpe = getAllPythonElements();
				fpe.forEach(pre => {
					// Create a new button element
					const button = document.createElement('img');
					button.src = "runCode.png";
					button.class = "runCode";
					//button.textContent = 'Run Python';  // Set the button text
					button.addEventListener('click', function() {
						let c = pre.querySelector("code.python");
						let execTooltip = document.querySelector(".execute-tooltip");
						execTooltip.style.display = 'block';
						let btnRect = this.getBoundingClientRect();
						runPython(c.textContent.trim());
						execTooltip.style.top = (btnRect.top + window.scrollY + btnRect.height/2 - (execTooltip.offsetHeight / 2))+"px";
						execTooltip.style.left = (btnRect.left + window.scrollX + this.offsetWidth + 20)+"px";
					});  // Attach the click event
					
					// Append the button to the <pre> element
					pre.appendChild(button);
				});
			}
			
			function updateCodeBlocks() {
				hljs.highlightAll();
				addRunPythonButtonsToFilteredPreElements();
			}
			
			function printDiv(txt, title) {
			  let mywindow = window.open('', 'PRINT', 'height=650,width=900,top=100,left=150');

			  mywindow.document.write(`<html><head><title>${title}</title>`);
			  mywindow.document.write('</head><body >');
			  mywindow.document.write(txt);
			  mywindow.document.write('</body></html>');

			  mywindow.document.close(); // necessary for IE >= 10
			  mywindow.focus(); // necessary for IE >= 10*/

			  mywindow.print();
			  mywindow.close();

			  return true;
			}

			function generatePracticeHTML(data) {
				const container = document.getElementById('practiceTest');
				container.innerHTML = ''; // Clear existing content

				data.forEach((item, index) => {
					// Create question element
					const questionElem = document.createElement('div');
					questionElem.classList.add("practiceExamQuestion");
					questionElem.innerHTML = converter.makeHtml(item.question);

					// Create answers list
					/*const ul = document.createElement('select');
					ul.size = item.answers.length;*/
					const ul = document.createElement('div');
					ul.classList.add('answers');
					let i = 0;
					let order = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];
					item.answers.forEach((answer, i) => {
						const dv = document.createElement("div");
						dv.classList.add("wrapper2");
						const li = document.createElement('input');
						li.type = "radio";
						li.name = `question${index}`;
						li.id = `question${index}-${order[i]}`;
						li.value = order[i];
						
						//li.innerHTML = converter.makeHtml(answer);
						const label = document.createElement("label");
						label.htmlFor = `question${index}-${order[i]}`;
						label.innerHTML = converter.makeHtml(answer);
						
						ul.appendChild(dv);
						dv.appendChild(li);
						dv.appendChild(label);
						i+=1;
					});

					// Append question and answers to the container
					container.appendChild(questionElem);
					questionElem.appendChild(ul);

					updateCodeBlocks();
				});
			}

			function checkPracticeExam() {
				let questions = document.getElementById("practiceTest").querySelectorAll("div.practiceExamQuestion");
				let i = 0;
				let total = questions.length;
				let right = 0;
				questions.forEach((element,index) => {
					console.log(examDict[i].correct_answer);
					let sel = document.querySelector(`input[name="question${index}"]:checked`);
					let correct = false;
					if (sel != null) {
						correct = (sel.value != null) && examDict[i].correct_answer == sel.value
					}
					if (correct) {right += 1;}
					element.classList.remove("correct");
					element.classList.remove("incorrect");
					element.classList.add(correct ? "correct" : "incorrect");

					if (!correct && element.querySelector(".showRightAnswer") == null) {
						const b = document.createElement("b");
						b.classList.add("showRightAnswer");
						b.textContent = "Correct Answer: " + examDict[i].correct_answer;
						element.appendChild(b);

						let whyButton = document.createElement("button");
						whyButton.classList.add("whyButton");
						whyButton.classList.add("animBtn");
						whyButton.textContent = "Why?";
						element.appendChild(whyButton);

						let explanDiv = document.createElement("div"); // This is where our explanation will go
						explanDiv.classList.add("explanation");
						element.appendChild(explanDiv);
						
						let dict = JSON.stringify(examDict[i]);
						whyButton.addEventListener("click", async function() {
							// Copy/paste the chat code from below here, and stick the results in explanDiv
							let pr = `Question Data: ${dict} \n\n Chosen answer: ${(sel == null ? "No Answer Chosen" : sel.value)} \n\n Above is some information on a practice problem. Explain why the chosen answer is wrong, and why the correct answer is right. You have 50 words to do so.`;
							console.log(pr);
							const result = await chatModel.generateContentStream(pr);
							let contents = "";
							// Print text as it comes in. This is a deviation from the standard function.
							for await (const chunk of result.stream) {
								const chunkText = chunk.text();
								contents += chunkText;
								explanDiv.innerHTML = converter.makeHtml(contents);
							}
							playSound("noise.wav");
							updateCodeBlocks();
						});
					};
					i+=1;
				});

				setGrade(right+"/"+total+`(${(right/(1.0*total))}%)`);
			}
			
			function playSound(url) {
			  const audio = new Audio(url);
			  audio.play();
			}

			function refreshModel() {
				model = genAI.getGenerativeModel({ model: modelId, systemInstruction: `You write textbooks and sections for textbooks and are ${tone}`, safetySettings});
			}

			function resetTone() {
				tone = "Professional, detailed";
				document.getElementById("tone").value = tone;
			}

			function updateTone() {
				let v = document.getElementById("tone").value;
				if (v.trim() == "") {
					resetTone();
				}
				localStorage.setItem("tone",v.trim());
				tone = v.trim();
				refreshModel();
			}
			
			function updateListBox() {
				var select = document.getElementById('pagedict');
				select.innerHTML = "";
				for (const key in bookDict){
					var opt = document.createElement('option');
					opt.value = key;
					opt.innerHTML = key;
					select.appendChild(opt);
				}
			}
			
			function resetBook() {
				bookDict = {};
				closeCodeTooltip();
				updateListBox();
			}

			
			
			function fullBook() {
				let fullText = "";
				let i = 0;
				for (const key in bookDict) {

					fullText += `Page ${i}: ${key}\n\n` + bookDict[key] + "\n\n\n";
					i+=1;
				}
				fullText = fullText.replace(/<code>.*?<\/code>/gs, '');
				return fullText;
			}
			
			function addToBook(key,value) {
				bookDict[key] = value;
				updateListBox();
			}

			function toTitleCase(str) { //Thank you stack overflow!
				return str.replace(
					/\w\S*/g,
					text => text.charAt(0).toUpperCase() + text.substring(1).toLowerCase()
				);
			}
			
			function setPage(key) {
				window.scrollTo({ top: 0, behavior: 'smooth' });
				body.innerHTML = converter.makeHtml(bookDict[key]);
				let tabName = toTitleCase(key);
				if (tabName.length > 20) {
					tabName = tabName.substring(0,17)+"...";
				}
				document.getElementById("label1").textContent = tabName;
				updateCodeBlocks();
				closeCodeTooltip();
			}

			function setGrade(grade) {
				document.getElementById("grade").textContent = grade;
			};
			
			async function generateBook() {
				let topic = textbox.value.trim();
				let complexity = document.getElementById("writeComplexity").value;
				if (topic == "") {
					alert("Please provide a prompt! Example: How to write Python code");
					return;
				}
				resetBook();
				
				let tpcPrompt = `Write a list of ${document.getElementById("quantity").value} topics relating to ${topic}. Include EXACTLY as many topics (${document.getElementById("quantity").value}) as requested, no more or less. The topics chosen should be ${complexity} in nature but ALWAYS relevant. Do not include a title or header for the list or any extra newlines. Only include the list elements with numbers. Use ONLY ASCII-safe characters. The first page should ALWAYS be a page talking broadly about the concept. Do not pick redundant topics. Do not provide anything in your response other than the list. Make sure each page covers a different aspect of ${topic}. Do not describe or provide detail to each topic here, only list them. If you include code examples, do not include their output.`;
				console.log(tpcPrompt);
				status.textContent = "Creating list of pages";
				let topicResponse = await generateResponse(tpcPrompt, tocModel);
				let topics = topicResponse.split('\n');
				topics = topics.filter(n => n);
				let topicFinal = "<h1>Table of Contents:</h2><br>";
				for (const tpc1 of topics) {
					topicFinal += "<p>"+tpc1+"</p>";
				}
				addToBook("Table of Contents", topicFinal);
				setPage("Table of Contents");

				
				let pageLength = document.getElementById("writeLength").value;

				let i = 1;
				for (const tpc of topics) {
					console.log(tpc);
					status.textContent = `Writing page ${i}/${topics.length}`;
					let pagePrompt = fullBook() + `Above is the full contents of the chapter until now. Your job is to write a lengthy and informative MARKDOWN-FRIENDLY section for a textbook on ${tpc} in ${topic} geared towards ${complexity}. Write at LEAST ${lengthDict[pageLength]} words and without a conclusion or concluding section. Be very lengthy, detailed, and very informative. IMPORTANT: DO NOT INCLUDE THE PAGE TITLE MORE THAN ONCE!!!!! Don't just write a list with a bunch of one-sentence snippets- write full paragraphs, and MAINTAIN THE STYLE AND STRUCTURE OF THE ABOVE BOOK. DO NOT repeat material already covered in previous chapters. Write as much as possible on the topic, and do not be afraid of lengthy paragraphs if need be. If you include blocks of code in your response, do not include their output. A button built into the textbook viewer will show their output for you.`;
					let page = await generateResponse(pagePrompt);
					addToBook(tpc,converter.makeHtml(page));
					i+=1;
				}

				if (document.getElementById("addglossary").checked) {
					status.textContent = "Adding Glossary";
					let pagePrompt = fullBook() + `Above is the full contents of the chapter until now. Write a glossary for terms used in the above, using a markdown unordered list. Write all key terms. DO NOT write any more than the glossary.`;
					let page = await generateResponse(pagePrompt);
					addToBook("Glossary",converter.makeHtml(page));
				}

				status.textContent = "Done!";
			}

			async function generatePracticeExam(source, qCount, difficulty) {
				/*let prompt = fullBook() + `\n\nAbove is the full book. Write a multiple-choice practice test for the above text with 10 questions. Format each question like this, following all newline procedures as I am:

{ "question": "This is where the question goes", "answers":["A: This is Answer A","B: This is answer B"]},`;*/
				let prompt = source + `\n\nWrite a multiple-choice practice test for the above content with ${qCount} questions. It should be ${difficultyDict[difficulty]} in terms of difficulty. Do not put "\`\`\`json" at the start of the response, nor "\`\`\`" at the end. Format each question like this, following all newline procedures as I am:

{ "question": "This is where the question goes", "answers":["A: This is Answer A","B: This is answer B"], "correct_answer": "A"},
 
Make sure not to put a comma after the last question.`;
				setGrade("");
				status.textContent = "Creating exam";
				let response = await generateResponse(prompt);
				response = "["+response+"]";
				console.log(response);
				let json = JSON.parse(response);
				examDict = json;
				console.log(examDict);
				status.textContent = "Done!";
				generatePracticeHTML(examDict);
				document.getElementById("checkPracticeExam").style.display = "block";
			}

			async function generateFlashCards(source) {
				let prompt = source + `\n\n Above is your source text. Write 10 flash cards using the source text to help reinforce understanding. Do not put "\`\`\`json" at the start of the response, nor "\`\`\`" at the end. Format each question like this, following all newline procedures as I am:
				
				{ "front": "This is where you put the term/concept!", "back": "This is where you put a definition (15 words or less)!"},`;

				status.textContent = "Creating flashcards";
				let response = await generateResponse(prompt);
				response = "["+response+"]";
				console.log(response);
				let json = JSON.parse(response);
				flashcards = json;
				console.log(flashcards);
				status.textContent = "Done!";
				currentCardIndex = 0;
				displayFlashcard(currentCardIndex);
			}

			
			
			async function addPage() {
				let tpc = document.getElementById("newPageInp").value;
				let complexity = document.getElementById("writeComplexity").value;
				let pageLength = document.getElementById("writeLength").value;
				if (tpc == "") { return; }
				status.textContent = `Adding page`;
				let pagePrompt = fullBook() + `Above is the full contents of the chapter until now. Your job is to write a lengthy and informative section for a textbook on ${tpc} geared towards ${complexity}. Write at LEAST ${lengthDict[pageLength]} words and without a conclusion or concluding section. Be very lengthy, detailed, and very informative. DO NOT repeat material already covered in previous chapters. IMPORTANT: DO NOT INCLUDE THE PAGE TITLE MORE THAN ONCE!!!!! Don't just write a list with a bunch of one-sentence snippets- write full paragraphs, and MAINTAIN THE STYLE AND STRUCTURE OF THE ABOVE BOOK. Write as much as possible on the topic, and do not be afraid of lengthy paragraphs if need be.`;
				let page = await generateResponse(pagePrompt);
				addToBook(tpc,converter.makeHtml(page));
				status.textContent = `Done!`;
			}
			
			async function generateResponse(prompt, mdl, depth) {
				closeCodeTooltip();
				if (mdl == null) {
					mdl = model;
				}
				//const prompt = textbox.value;
				if (depth == null) {
					depth = 0;
				}
				let contents = "";
				refreshModel();
				try {
					console.log(prompt);
					const result = await mdl.generateContentStream(prompt);
					
					// Print text as it comes in.
					for await (const chunk of result.stream) {
						//console.log(chunk);
						const chunkText = chunk.text();
						contents += chunkText;
					}
					console.log("**********RESULT*********\n\n\n\n\n\n");
					console.log(result);
					//console.log("getting here!" + contents);
					playSound("noise.wav");
				} catch (error) {
					if (depth < 3) {
						contents = generateResponse(prompt,mdl, depth+1);
					}
					else {
						return "Uh oh! There was an issue generating this page. There is a known issue with the backend having a 'recitation error', meaning the AI can't quite find its sources and aborts. They're working on a fix to this issue. Sorry!";
					}
				}
				
				return contents;
			}

			function closeCodeTooltip() {
				document.querySelector(".execute-tooltip").style.display = "none";
			}
			
			window.addEventListener("load", (event) => {
				body = document.getElementById("textgohere");
				textbox = document.getElementById("inp");
				textbox.value = startingPrompts[[Math.floor(Math.random()*startingPrompts.length)]];
				status = document.getElementById("status");
				document.getElementById("btn").addEventListener("click",generateBook);
				document.getElementById("printBtn").addEventListener("click",printPDF);
				document.getElementById("newPageButton").addEventListener("click",addPage);
				document.getElementById("writeFreeformPractice").addEventListener("click", async function() {
					let pr = `${document.getElementById("freeformTopic").value} \n\n Create a free-form practice problem using the concepts described in the provided text. Don't include statements about what the question will develop- only include the instructions, and DO NOT include the answer.`;
					await createFreeformPractice(pr);
				});
				let card = document.getElementById("flashcard-container");
				card.addEventListener('click', () => {
				card.classList.toggle('flipped');
				});
				document.getElementById("generatePracticeExam").addEventListener("click",async function() {
					if (Object.keys(bookDict).length == 0) {
						alert("Please generate a book first!");
						return;
					}
					await generatePracticeExam(fullBook(),document.getElementById("examLength").value,document.getElementById("examDifficulty").value);
				});
				document.getElementById("generate-flashcards").addEventListener("click", async function() {
					if (Object.keys(bookDict).length == 0) {
						alert("Please generate a book first!");
						return;
					}
					await generateFlashCards(fullBook());
				});
				document.getElementById("checkPracticeExamBtn").addEventListener("click",checkPracticeExam);
				document.getElementById("quantity").value = "5"; 

				document.querySelector(".close-button").addEventListener("click", closeCodeTooltip);

				document.getElementById("prevBtn").addEventListener("click", () => {
					displayFlashcard(currentCardIndex - 1);
				});

				document.getElementById("nextBtn").addEventListener("click", () => {
					displayFlashcard(currentCardIndex + 1);
				});
				
				document.getElementById('pagedict').addEventListener("change", function() {
					document.getElementById('tab1').click();
					setPage(document.getElementById('pagedict').value);
				});

				document.getElementById("resetTone").addEventListener("click",resetTone);

				document.getElementById("tone").addEventListener("change", updateTone);
				document.getElementById("writeLength").addEventListener("change", function() {
					localStorage.setItem("length",document.getElementById("writeLength").value);
				});

				if (localStorage.getItem("length")!= null) {
					document.getElementById("writeLength").value = localStorage.getItem("length");
				} else {
					document.getElementById("writeLength").value = "Very Long";
				}

				localStorage.setItem("length",document.getElementById("writeLength").value);

				document.getElementById("writeComplexity").addEventListener("change", function() {
					localStorage.setItem("complexity",document.getElementById("writeComplexity").value);
				});

				if (localStorage.getItem("complexity")!= null) {
					document.getElementById("writeComplexity").value = localStorage.getItem("complexity");
				} else {
					document.getElementById("writeComplexity").value = "Beginner";
				}

				localStorage.setItem("complexity",document.getElementById("writeComplexity").value);

				document.getElementById("examLength").addEventListener("change", function() {
					localStorage.setItem("examLength",document.getElementById("examLength").value);
				});

				if (localStorage.getItem("examLength")!= null) {
					document.getElementById("examLength").value = localStorage.getItem("examLength");
				} else {
					document.getElementById("examLength").value = "10";
				}

				localStorage.setItem("examLength",document.getElementById("examLength").value);

				document.getElementById("examDifficulty").addEventListener("change", function() {
					localStorage.setItem("examDifficulty",document.getElementById("examDifficulty").value);
				});

				if (localStorage.getItem("examDifficulty")!= null) {
					document.getElementById("examDifficulty").value = localStorage.getItem("examDifficulty");
				} else {
					document.getElementById("examDifficulty").value = "medium";
				}

				localStorage.setItem("examDifficulty",document.getElementById("examDifficulty").value);

				if (localStorage.getItem("tone") != null) {
					tone = localStorage.getItem("tone");
					document.getElementById("tone").value = tone;
				} else {
					resetTone();
				}
				localStorage.setItem("tone",tone);
			});
			
			function checkTooltip()  {
				requestAnimationFrame(() => {
					const selection = window.getSelection();
					const text = selection.toString().replace(/\s/g, "");
					let chat = document.getElementById("chatgohere");
					let pTest = document.getElementById("practiceTest");
					if (!(body.textContent.replace(/\s/g, "").includes(text)||chat.textContent.replace(/\s/g, "").includes(text)|pTest.textContent.replace(/\s/g, "").includes(text))) {
						elabTooltip.style.display = "none";
						return;
					}
					
					if (selection.isCollapsed) {
						elabTooltip.style.display = "none";
						return;
					}
					
					const rect = selection.getRangeAt(0).getBoundingClientRect();
					elabTooltip.style.display = 'flex';
					elabTooltip.style.left = `${rect.left + rect.width/2 - elabTooltip.clientWidth/2}px`;
					let top = rect.top - elabTooltip.clientHeight + window.scrollY;
					if (top < window.scrollY) {
						top = window.scrollY + 25;
					}
					if (top > window.scrollY+window.innerHeight) {
						top = window.innerHeight - 25;
					}
					elabTooltip.style.top = `${top}px`;
				});
			}

			const elabTooltip = document.querySelector(".elaborate-tooltip");
			document.addEventListener("mouseup", checkTooltip);
			if (mobileAndTabletCheck()) {
				document.addEventListener("selectionchange", checkTooltip);
			}
			
			window.onscroll = function (e)
			{
				elabTooltip.style.display = "none";
			}
			
			const chatButton = document.getElementById("chatButton");
			chatButton.addEventListener("click", async function() {
				let text = document.getElementById("chatInp").value;
				let lastChat = document.getElementById("chatgohere").textContent;
				let pr = `${text}\n\nRespond to the above message. Be thorough and detailed and include at least ${lengthDict[document.getElementById("writeLength").value]/2} words. Refer back to the contents of the below book and the prior chat, if any: BOOK CONTENTS: \n\n${fullBook()} \n\n CHAT CONTENTS: \n\n${lastChat}`;
				document.getElementById("chatgohere").innerHTML = `<h1>Awaiting response...</h1>`;
				window.scrollTo({ top: 0, behavior: 'smooth' });
				const result = await chatModel.generateContentStream(pr);
				let contents = "";
				// Print text as it comes in. This is a deviation from the standard function.
				for await (const chunk of result.stream) {
					const chunkText = chunk.text();
					contents += chunkText;
					document.getElementById("chatgohere").innerHTML = converter.makeHtml(contents);
				}
				playSound("noise.wav");
				updateCodeBlocks();
			});
			
			const elabButton = document.querySelector(".elaborate-button");
			elabButton.addEventListener("mousedown", async function() {
				const selection = window.getSelection();
				const selectedText = selection.toString();
				let pr = `${selectedText} \n\n Elaborate on the above text. Provide details and include at least ${lengthDict[document.getElementById("writeLength").value]} words. Be thorough. Refer back to the contents of the below book: \n\n${fullBook()}`;
				document.getElementById('tab2').click();
				document.getElementById("chatgohere").innerHTML = `<h1>Elaborating...</h1>`;
				window.scrollTo({ top: 0, behavior: 'smooth' });
				const result = await chatModel.generateContentStream(pr);
				let contents = "";
				// Print text as it comes in. This is a deviation from the standard function.
				for await (const chunk of result.stream) {
					const chunkText = chunk.text();
					contents += chunkText;
					document.getElementById("chatgohere").innerHTML = converter.makeHtml(contents);
				}
				playSound("noise.wav");
				updateCodeBlocks();
			});
			
			async function createFreeformPractice(pr) {
				document.getElementById('tab4').click();
				document.getElementById("question").innerHTML = `<h1>Writing Practice Problem...</h1>`;
				window.scrollTo({ top: 0, behavior: 'smooth' });
				console.log(pr);
				const result = await practiceModel.generateContentStream(pr);
				let contents = "";
				// Print text as it comes in. This is a deviation from the standard function.
				for await (const chunk of result.stream) {
					const chunkText = chunk.text();
					contents += chunkText;
					document.getElementById("question").innerHTML = converter.makeHtml(contents);
				}
				updateCodeBlocks();
				playSound("noise.wav");
			}


			const pracButton = document.querySelector(".practice-button");
			pracButton.addEventListener("mousedown", async function() {
				const selection = window.getSelection();
				const selectedText = selection.toString();
				let pr = `${selectedText} \n\n Create a free-form practice problem using the concepts described in the provided text. Don't include statements about what the question will develop- only include the instructions, and DO NOT include the answer.`;
				await createFreeformPractice(pr);
			});

			const testButton = document.querySelector(".test-button");
			testButton.addEventListener("mousedown", async function() {
				const selection = window.getSelection();
				const selectedText = selection.toString();
				document.getElementById('tab5').click();
				window.scrollTo({ top: 0, behavior: 'smooth' });
				await generatePracticeExam(selectedText,"5","medium");
				updateCodeBlocks();
			});

			const studyButton = document.querySelector(".study-button");
			studyButton.addEventListener("mousedown", async function() {
				const selection = window.getSelection();
				const selectedText = selection.toString();
				document.getElementById('tab6').click();
				window.scrollTo({ top: 0, behavior: 'smooth' });
				await generateFlashCards(selectedText);
				updateCodeBlocks();
			});
			
			const answerButton = document.getElementById("answerButton");
			answerButton.addEventListener("mousedown", async function() {
				
				let text = document.getElementById("question").textContent;
				let answer = document.getElementById("answerInp").value;
				if (text.trim() == "" || answer.trim() == "" || text.trim() == "Question") {
					alert("Uh oh! Make sure you have a question and an answer.");
					return;
				}
				let pr = `${text}\n\n\n This is a practice problem. Below is what I answered: \n\n\n ${answer} \n\n Tell me if it is correct or not. If it's incorrect, explain why. Don't include my solution in your response.`;
				document.getElementById("answer").innerHTML = `<h1>Awaiting response...</h1>`;
				window.scrollTo({ top: 0, behavior: 'smooth' });
				const result = await model.generateContentStream(pr);
				let contents = "";
				// Print text as it comes in. This is a deviation from the standard function.
				for await (const chunk of result.stream) {
					const chunkText = chunk.text();
					contents += chunkText;
					document.getElementById("answer").innerHTML = converter.makeHtml(contents);
				}
				updateCodeBlocks();
				playSound("noise.wav");
			});
			
			function printPDF() {
				printDiv(converter.makeHtml(fullBook()), "Book");
			}

			var coll = document.getElementsByClassName("collapsible");
			var i;

			for (i = 0; i < coll.length; i++) {
			coll[i].addEventListener("click", function() {
				this.classList.toggle("activeCollapse");
				var content = this.nextElementSibling;
				if (content.style.display === "block") {
				content.style.display = "none";
				} else {
				content.style.display = "block";
				}
			});
			} 
			
		</script>
		<div class="elaborate-tooltip tooltip">
			<div class="elaborate-button">Elaborate</div><div class="practice-button">Practice</div><div class="test-button">Pop Quiz</div><div class="study-button">Flash Cards</div>
		</div>
		<div class="execute-tooltip tooltip">
			<button class="close-button">Close</button>
			<pre id="output"></pre>
			<div id="mycanvas" width="350" height="350"></div> 
		</div>
		<div class="wrapper">
			<div class="sidebar">
				<div class="sections">
					<div class="section">
						<div id="fields">
						<h1>AI Textbooks</h1>
						
						<label for="imp">Chapter Topic:</label>
						<br>
						<textarea rows="5" style=" width: 90%; resize:none;" maxlength="180" placeholder="Prompt goes here..." id="inp"></textarea>
						<br>
						<br>
						<label for="quantity">Pages (3-10):</label>
						<input type="number" id="quantity" name="quantity" min="3" max="10" onkeyup="if(value<3) value=3; if (value > 10) value = 10;"><br><br>
						</div>
						
						<button id="btn" class="animBtn"><h3>Generate</h3></button>
						<br>
						<button type="button" class="collapsible">Advanced Settings</button>
						
						<div class="collapseContent">
							<h3>Writing Settings</h3>
							
							<div class="wrapper2" style="flex-direction: column; border: 2px solid black;">
								<div style="flex-grow: 1; padding: 10px">
									<p>Writing Tone</p>
									<textarea id="tone"></textarea>
									<br>
									<button id="resetTone" style="padding:10px;" class="animBtn2">Reset Tone</button>
									<br>
									<label for="addglossary">Include Glossary?</label>
									<input type="checkbox" id="addglossary">
								</div>
								<div style="flex-grow:1; padding: 10px;">
									<p>Writing Length</p>
									<select id="writeLength" size="4">
										<option value="Short">250 words/page</option>
										<option value="Medium">500 words/page</option>
										<option value="Long">1000 words/page</option>
										<option value="Very Long">2000 words/page</option>
									</select>
								</div>
								<div style="flex-grow:1; padding: 10px;">
									<p>Page Complexity</p>
									<select id="writeComplexity" size="4">
										<option value="Beginner">Beginner</option>
										<option value="Intermediate">Intermediate</option>
										<option value="Advanced">Advanced</option>
										<option value="Highly Advanced, Expert">Professional</option>
									</select>
								</div>
							</div>
						</div> 
						<select id="pagedict" Name="Table of Contents" size="10">
						</select>  
						<br>
						<div id="newPage">
							<input id="newPageInp"></input>
							<button id="newPageButton" class="animBtn">Add Page</button>
						
						</div>
						<br>
						<div id="status">Idle!</div>
					</div>
					
				</div>
			</div>
			<div id="body">
				<div class="container">
					<input type="radio" name="tab" id="tab1" checked>
					<label class="tab" for="tab1" id="label1">Book</label>
					<input type="radio" name="tab" id="tab2">
					<label class="tab" for="tab2">Chat</label>
					<input type="radio" name="tab" id="tab4">
					<label class="tab" for="tab4">Practice</label>
					<input type="radio" name="tab" id="tab6">
            		<label class="tab" for="tab6">Study</label>
					<input type="radio" name="tab" id="tab5">
					<label class="tab" for="tab5">Quiz</label>
					<input type="radio" name="tab" id="tab3">
					<label class="tab" for="tab3">Options</label>
					<div class="content1" id="content1">
						<div id="textgohere">
						The contents of your book will appear here!
						</div>
					</div>
					<div class="content2" id="chat">
						<div class="header" id="chatInputs">
							<h1>Study Partner</h1>
							<p>Go ahead and ask a question!</p>
							<fieldset>
								<textarea rows="5" style="width: 80%; resize:none;" placeholder="Your question goes here!" id="chatInp"></textarea>
								<br>
								<button class = "animBtn" id="chatButton">Ask!</button>
							</fieldset>
						</div>
						<br>
						<div id="chatgohere">
							Try sending a message!
						</div>
					</div>
					<div class="content4" id="content4">
						<div class="header">
							<h1>Practice Problem</h1>
							<p>Put your practice problem topic below. Test your skills!</p>
							<div id="chatInputs">
								<fieldset>
									<textarea rows="5" style="width: 80%; resize:none;" placeholder="Problem topic goes here!" id="freeformTopic"></textarea>
									<br>
									<button class = "animBtn" id="writeFreeformPractice">Create Problem!</button>
								</fieldset>
							</div>
						</div>
						<div class="wrapper">
							<div id="questionholder"> <!--There must be a good reason I did this with my HTML-->
								<div id="question">Question</div>
							</div>
							<div id = "answerholder"> <!--I don't think there is a good reason-->
								<div id="answer">
								Answer
								</div>
								
							</div>
						</div>
						<fieldset id="answerSection">
							<textarea id="answerInp" rows="5" style="width: 80%; resize:none;" placeholder="Your answer goes here!"></textarea>
							<button class="animBtn2" id="answerButton">Send</button>
						</fieldset>
					</div>
					<div class="content5" id="content5">
						<div class="header" id="examHeader">
							<h1>Pop Quiz</h1>
							<p>Content from all pages of your book will appear here. Get ready!</p>
							<div class="wrapper2">
								<select id="examLength" style = "flex-grow:1;" size="4">
									<option value="5">5 Questions</option>
									<option value="10">10 Questions</option>
									<option value="15">15 Questions</option>
									<option value="20">20 Questions</option>
								</select>
								<select id="examDifficulty" style = "flex-grow:1;" size="4">
									<option value="easy">Easy :)</option>
									<option value="medium">Medium :\</option>
									<option value="hard">Hard :(</option>
									<option value="impossible">Impossible >:(</option>
								</select>
							</div>
							<br>
							<button class="animBtn2" id="generatePracticeExam">Create Quiz</button>
							<h2 id="grade"></h2>
						</div>
						<div id="practiceTest">

						</div>
						<div id="checkPracticeExam">
							<button id="checkPracticeExamBtn">Check Exam</button>
						</div>
					</div>
					<div class="content6" id="content6">
						<div class="header">
							<h1>Flash Cards</h1>
							<p>Content from all pages of your book will appear here. Try it out!</p>
							<button id="generate-flashcards" class="animBtn">Study!</button>
						</div>
						<div id="flashcard-parent">
							<div id="flashcard-container">
								<div class="flashcard" id="flashcard">
									<div class="flashcard-front" id="flashcard-front">
										<!-- Front of the flashcard -->
									</div>
									<div class="flashcard-back" id="flashcard-back">
										<!-- Back of the flashcard -->
									</div>
								</div>
							</div>
							<div class="wrapper2">
								<button id="prevBtn" class="animBtn" style="flex-grow:1; font-size: 16px;">Previous</button>
								<button id="nextBtn" class="animBtn2" style="flex-grow:1; font-size: 16px;">Next</button>
							</div>
						</div>
					</div>
					<div class="content3" id="content3">
						<button class="animBtn" style="width: 25%; font-size: 16px;" id="printBtn">Print book as PDF</button>
						<br>
						<h2>Changelog</h2>
						<ul>
							<li>A new "Why?" button appears next to incorrectly answered questions in the Pop Quiz menu.</li>
							<li>Substantial QOL changes to improve the user experience.</li>
							<li>Site layout has been changed to make certain settings easier to access.</li>
							<li>Site layout has been changed to better retain consistency between pages.</li>
							<li>Prompts for most features have been improved to better match desired behaviors.</li>
						</ul>
						<p>A.P. 9/10/2024</p>
					</div>
					
					
			</div>
		</div>
		
		

		
	</body>

	
	
</html>